# Stubs for pandas.core.internals.blocks (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from pandas.core.base import PandasObject
from typing import Any, Optional

class Block(PandasObject):
    is_numeric: bool = ...
    is_float: bool = ...
    is_integer: bool = ...
    is_complex: bool = ...
    is_datetime: bool = ...
    is_datetimetz: bool = ...
    is_timedelta: bool = ...
    is_bool: bool = ...
    is_object: bool = ...
    is_categorical: bool = ...
    is_sparse: bool = ...
    is_extension: bool = ...
    ndim: Any = ...
    mgr_locs: Any = ...
    values: Any = ...
    def __init__(self, values: Any, placement: Any, ndim: Optional[Any] = ...) -> None: ...
    @property
    def is_view(self): ...
    @property
    def is_datelike(self): ...
    def is_categorical_astype(self, dtype: Any): ...
    def external_values(self, dtype: Optional[Any] = ...): ...
    def internal_values(self, dtype: Optional[Any] = ...): ...
    def formatting_values(self): ...
    def get_values(self, dtype: Optional[Any] = ...): ...
    def to_dense(self): ...
    @property
    def fill_value(self): ...
    @property
    def mgr_locs(self): ...
    @mgr_locs.setter
    def mgr_locs(self, new_mgr_locs: Any) -> None: ...
    @property
    def array_dtype(self): ...
    def make_block(self, values: Any, placement: Optional[Any] = ..., ndim: Optional[Any] = ...): ...
    def make_block_same_class(self, values: Any, placement: Optional[Any] = ..., ndim: Optional[Any] = ..., dtype: Optional[Any] = ...): ...
    def __unicode__(self): ...
    def __len__(self): ...
    def reshape_nd(self, labels: Any, shape: Any, ref_items: Any): ...
    def getitem_block(self, slicer: Any, new_mgr_locs: Optional[Any] = ...): ...
    @property
    def shape(self): ...
    @property
    def dtype(self): ...
    @property
    def ftype(self): ...
    def merge(self, other: Any): ...
    def concat_same_type(self, to_concat: Any, placement: Optional[Any] = ...): ...
    def iget(self, i: Any): ...
    def set(self, locs: Any, values: Any) -> None: ...
    def delete(self, loc: Any) -> None: ...
    def apply(self, func: Any, **kwargs: Any): ...
    def fillna(self, value: Any, limit: Optional[Any] = ..., inplace: bool = ..., downcast: Optional[Any] = ...): ...
    def split_and_operate(self, mask: Any, f: Any, inplace: Any): ...
    def downcast(self, dtypes: Optional[Any] = ...): ...
    def astype(self, dtype: Any, copy: bool = ..., errors: str = ..., values: Optional[Any] = ..., **kwargs: Any): ...
    def convert(self, copy: bool = ..., **kwargs: Any): ...
    def to_native_types(self, slicer: Optional[Any] = ..., na_rep: str = ..., quoting: Optional[Any] = ..., **kwargs: Any): ...
    def copy(self, deep: bool = ...): ...
    def replace(self, to_replace: Any, value: Any, inplace: bool = ..., filter: Optional[Any] = ..., regex: bool = ..., convert: bool = ...): ...
    def setitem(self, indexer: Any, value: Any): ...
    def putmask(self, mask: Any, new: Any, align: bool = ..., inplace: bool = ..., axis: int = ..., transpose: bool = ...): ...
    def coerce_to_target_dtype(self, other: Any): ...
    def interpolate(self, method: str = ..., axis: int = ..., index: Optional[Any] = ..., values: Optional[Any] = ..., inplace: bool = ..., limit: Optional[Any] = ..., limit_direction: str = ..., limit_area: Optional[Any] = ..., fill_value: Optional[Any] = ..., coerce: bool = ..., downcast: Optional[Any] = ..., **kwargs: Any): ...
    def take_nd(self, indexer: Any, axis: Any, new_mgr_locs: Optional[Any] = ..., fill_tuple: Optional[Any] = ...): ...
    def diff(self, n: Any, axis: int = ...): ...
    def shift(self, periods: Any, axis: int = ..., fill_value: Optional[Any] = ...): ...
    def where(self, other: Any, cond: Any, align: bool = ..., errors: str = ..., try_cast: bool = ..., axis: int = ..., transpose: bool = ...): ...
    def equals(self, other: Any): ...
    def quantile(self, qs: Any, interpolation: str = ..., axis: int = ...): ...

class NonConsolidatableMixIn:
    def __init__(self, values: Any, placement: Any, ndim: Optional[Any] = ...) -> None: ...
    @property
    def shape(self): ...
    def iget(self, col: Any): ...
    def should_store(self, value: Any): ...
    values: Any = ...
    def set(self, locs: Any, values: Any, check: bool = ...) -> None: ...
    def putmask(self, mask: Any, new: Any, align: bool = ..., inplace: bool = ..., axis: int = ..., transpose: bool = ...): ...

class ExtensionBlock(NonConsolidatableMixIn, Block):
    is_extension: bool = ...
    def __init__(self, values: Any, placement: Any, ndim: Optional[Any] = ...) -> None: ...
    @property
    def fill_value(self): ...
    @property
    def is_view(self): ...
    @property
    def is_numeric(self): ...
    def setitem(self, indexer: Any, value: Any): ...
    def get_values(self, dtype: Optional[Any] = ...): ...
    def to_dense(self): ...
    def take_nd(self, indexer: Any, axis: int = ..., new_mgr_locs: Optional[Any] = ..., fill_tuple: Optional[Any] = ...): ...
    def formatting_values(self): ...
    def concat_same_type(self, to_concat: Any, placement: Optional[Any] = ...): ...
    def fillna(self, value: Any, limit: Optional[Any] = ..., inplace: bool = ..., downcast: Optional[Any] = ...): ...
    def interpolate(self, method: str = ..., axis: int = ..., inplace: bool = ..., limit: Optional[Any] = ..., fill_value: Optional[Any] = ..., **kwargs: Any): ...
    def shift(self, periods: Any, axis: int = ..., fill_value: Optional[Any] = ...): ...
    def where(self, other: Any, cond: Any, align: bool = ..., errors: str = ..., try_cast: bool = ..., axis: int = ..., transpose: bool = ...): ...

class ObjectValuesExtensionBlock(ExtensionBlock):
    def external_values(self, dtype: Optional[Any] = ...): ...

class NumericBlock(Block):
    is_numeric: bool = ...

class FloatOrComplexBlock(NumericBlock):
    def equals(self, other: Any): ...

class FloatBlock(FloatOrComplexBlock):
    is_float: bool = ...
    def to_native_types(self, slicer: Optional[Any] = ..., na_rep: str = ..., float_format: Optional[Any] = ..., decimal: str = ..., quoting: Optional[Any] = ..., **kwargs: Any): ...
    def should_store(self, value: Any): ...

class ComplexBlock(FloatOrComplexBlock):
    is_complex: bool = ...
    def should_store(self, value: Any): ...

class IntBlock(NumericBlock):
    is_integer: bool = ...
    def should_store(self, value: Any): ...

class DatetimeLikeBlockMixin:
    @property
    def fill_value(self): ...
    def get_values(self, dtype: Optional[Any] = ...): ...

class DatetimeBlock(DatetimeLikeBlockMixin, Block):
    is_datetime: bool = ...
    def __init__(self, values: Any, placement: Any, ndim: Optional[Any] = ...) -> None: ...
    def to_native_types(self, slicer: Optional[Any] = ..., na_rep: Optional[Any] = ..., date_format: Optional[Any] = ..., quoting: Optional[Any] = ..., **kwargs: Any): ...
    def should_store(self, value: Any): ...
    def set(self, locs: Any, values: Any) -> None: ...
    def external_values(self): ...

class DatetimeTZBlock(ExtensionBlock, DatetimeBlock):
    is_datetimetz: bool = ...
    is_extension: bool = ...
    @property
    def is_view(self): ...
    def copy(self, deep: bool = ...): ...
    def get_values(self, dtype: Optional[Any] = ...): ...
    def to_dense(self): ...
    def diff(self, n: Any, axis: int = ...): ...
    def concat_same_type(self, to_concat: Any, placement: Optional[Any] = ...): ...
    def fillna(self, value: Any, limit: Optional[Any] = ..., inplace: bool = ..., downcast: Optional[Any] = ...): ...
    def setitem(self, indexer: Any, value: Any): ...
    def equals(self, other: Any): ...

class TimeDeltaBlock(DatetimeLikeBlockMixin, IntBlock):
    is_timedelta: bool = ...
    is_numeric: bool = ...
    def __init__(self, values: Any, placement: Any, ndim: Optional[Any] = ...) -> None: ...
    def fillna(self, value: Any, **kwargs: Any): ...
    def should_store(self, value: Any): ...
    def to_native_types(self, slicer: Optional[Any] = ..., na_rep: Optional[Any] = ..., quoting: Optional[Any] = ..., **kwargs: Any): ...
    def external_values(self, dtype: Optional[Any] = ...): ...

class BoolBlock(NumericBlock):
    is_bool: bool = ...
    def should_store(self, value: Any): ...
    def replace(self, to_replace: Any, value: Any, inplace: bool = ..., filter: Optional[Any] = ..., regex: bool = ..., convert: bool = ...): ...

class ObjectBlock(Block):
    is_object: bool = ...
    def __init__(self, values: Any, placement: Optional[Any] = ..., ndim: int = ...) -> None: ...
    @property
    def is_bool(self): ...
    def convert(self, *args: Any, **kwargs: Any): ...
    values: Any = ...
    def set(self, locs: Any, values: Any) -> None: ...
    def should_store(self, value: Any): ...
    def replace(self, to_replace: Any, value: Any, inplace: bool = ..., filter: Optional[Any] = ..., regex: bool = ..., convert: bool = ...): ...

class CategoricalBlock(ExtensionBlock):
    is_categorical: bool = ...
    def __init__(self, values: Any, placement: Any, ndim: Optional[Any] = ...) -> None: ...
    @property
    def array_dtype(self): ...
    def to_dense(self): ...
    def to_native_types(self, slicer: Optional[Any] = ..., na_rep: str = ..., quoting: Optional[Any] = ..., **kwargs: Any): ...
    def concat_same_type(self, to_concat: Any, placement: Optional[Any] = ...): ...
    def where(self, other: Any, cond: Any, align: bool = ..., errors: str = ..., try_cast: bool = ..., axis: int = ..., transpose: bool = ...): ...

def get_block_type(values: Any, dtype: Optional[Any] = ...): ...
def make_block(values: Any, placement: Any, klass: Optional[Any] = ..., ndim: Optional[Any] = ..., dtype: Optional[Any] = ..., fastpath: Optional[Any] = ...): ...
