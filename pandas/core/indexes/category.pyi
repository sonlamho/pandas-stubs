# Stubs for pandas.core.indexes.category (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from pandas.core import accessor
from pandas.core.indexes.base import Index
from typing import Any, Optional

class CategoricalIndex(Index, accessor.PandasDelegate):
    def __new__(
        cls,
        data: Optional[Any] = ...,
        categories: Optional[Any] = ...,
        ordered: Optional[Any] = ...,
        dtype: Optional[Any] = ...,
        copy: bool = ...,
        name: Optional[Any] = ...,
        fastpath: Optional[Any] = ...,
    ): ...
    def equals(self, other: Any): ...
    @property
    def inferred_type(self): ...
    @property
    def values(self): ...
    @property
    def itemsize(self): ...
    def get_values(self): ...
    def tolist(self): ...
    @property
    def codes(self): ...
    @property
    def categories(self): ...
    @property
    def ordered(self): ...
    def __contains__(self, key: Any): ...
    def contains(self, key: Any): ...
    def __array__(self, dtype: Optional[Any] = ...): ...
    def astype(self, dtype: Any, copy: bool = ...): ...
    def fillna(self, value: Any, downcast: Optional[Any] = ...): ...
    def argsort(self, *args: Any, **kwargs: Any): ...
    def is_unique(self): ...
    @property
    def is_monotonic_increasing(self): ...
    @property
    def is_monotonic_decreasing(self): ...
    def unique(self, level: Optional[Any] = ...): ...
    def duplicated(self, keep: str = ...): ...
    def get_loc(self, key: Any, method: Optional[Any] = ...): ...
    def get_value(self, series: Any, key: Any): ...
    def where(self, cond: Any, other: Optional[Any] = ...): ...
    def reindex(
        self,
        target: Any,
        method: Optional[Any] = ...,
        level: Optional[Any] = ...,
        limit: Optional[Any] = ...,
        tolerance: Optional[Any] = ...,
    ): ...
    def get_indexer(
        self,
        target: Any,
        method: Optional[Any] = ...,
        limit: Optional[Any] = ...,
        tolerance: Optional[Any] = ...,
    ): ...
    def get_indexer_non_unique(self, target: Any): ...
    def take(
        self,
        indices: Any,
        axis: int = ...,
        allow_fill: bool = ...,
        fill_value: Optional[Any] = ...,
        **kwargs: Any
    ): ...
    def is_dtype_equal(self, other: Any): ...
    take_nd: Any = ...
    def map(self, mapper: Any): ...
    def delete(self, loc: Any): ...
    def insert(self, loc: Any, item: Any): ...
