# Stubs for pandas.core.window (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from pandas.core.base import PandasObject, SelectionMixin
from pandas.core.groupby.base import GroupByMixin
from typing import Any, Optional

class _Window(PandasObject, SelectionMixin):
    exclusions: Any = ...
    blocks: Any = ...
    obj: Any = ...
    on: Any = ...
    closed: Any = ...
    window: Any = ...
    min_periods: Any = ...
    center: Any = ...
    win_type: Any = ...
    win_freq: Any = ...
    axis: Any = ...
    def __init__(
        self,
        obj: Any,
        window: Optional[Any] = ...,
        min_periods: Optional[Any] = ...,
        center: bool = ...,
        win_type: Optional[Any] = ...,
        axis: int = ...,
        on: Optional[Any] = ...,
        closed: Optional[Any] = ...,
        **kwargs: Any
    ) -> None: ...
    @property
    def is_datetimelike(self) -> None: ...
    @property
    def is_freq_type(self): ...
    def validate(self) -> None: ...
    def __getattr__(self, attr: Any): ...
    def __unicode__(self): ...
    def __iter__(self) -> None: ...
    def aggregate(self, arg: Any, *args: Any, **kwargs: Any): ...
    agg: Any = ...

class Window(_Window):
    def validate(self) -> None: ...
    def aggregate(self, arg: Any, *args: Any, **kwargs: Any): ...
    agg: Any = ...
    def sum(self, *args: Any, **kwargs: Any): ...
    def mean(self, *args: Any, **kwargs: Any): ...

class _GroupByMixin(GroupByMixin):
    def __init__(self, obj: Any, *args: Any, **kwargs: Any) -> None: ...
    count: Any = ...
    corr: Any = ...
    cov: Any = ...

class _Rolling(_Window): ...

class _Rolling_and_Expanding(_Rolling):
    def count(self): ...
    def apply(
        self, func: Any, raw: Optional[Any] = ..., args: Any = ..., kwargs: Any = ...
    ): ...
    def sum(self, *args: Any, **kwargs: Any): ...
    def max(self, *args: Any, **kwargs: Any): ...
    def min(self, *args: Any, **kwargs: Any): ...
    def mean(self, *args: Any, **kwargs: Any): ...
    def median(self, **kwargs: Any): ...
    def std(self, ddof: int = ..., *args: Any, **kwargs: Any): ...
    def var(self, ddof: int = ..., *args: Any, **kwargs: Any): ...
    def skew(self, **kwargs: Any): ...
    def kurt(self, **kwargs: Any): ...
    def quantile(self, quantile: Any, interpolation: str = ..., **kwargs: Any): ...
    def cov(
        self,
        other: Optional[Any] = ...,
        pairwise: Optional[Any] = ...,
        ddof: int = ...,
        **kwargs: Any
    ): ...
    def corr(
        self, other: Optional[Any] = ..., pairwise: Optional[Any] = ..., **kwargs: Any
    ): ...

class Rolling(_Rolling_and_Expanding):
    def is_datetimelike(self): ...
    win_freq: Any = ...
    window: Any = ...
    win_type: str = ...
    min_periods: int = ...
    def validate(self) -> None: ...
    def aggregate(self, arg: Any, *args: Any, **kwargs: Any): ...
    agg: Any = ...
    def count(self): ...
    def apply(
        self, func: Any, raw: Optional[Any] = ..., args: Any = ..., kwargs: Any = ...
    ): ...
    def sum(self, *args: Any, **kwargs: Any): ...
    def max(self, *args: Any, **kwargs: Any): ...
    def min(self, *args: Any, **kwargs: Any): ...
    def mean(self, *args: Any, **kwargs: Any): ...
    def median(self, **kwargs: Any): ...
    def std(self, ddof: int = ..., *args: Any, **kwargs: Any): ...
    def var(self, ddof: int = ..., *args: Any, **kwargs: Any): ...
    def skew(self, **kwargs: Any): ...
    def kurt(self, **kwargs: Any): ...
    def quantile(self, quantile: Any, interpolation: str = ..., **kwargs: Any): ...
    def cov(
        self,
        other: Optional[Any] = ...,
        pairwise: Optional[Any] = ...,
        ddof: int = ...,
        **kwargs: Any
    ): ...
    def corr(
        self, other: Optional[Any] = ..., pairwise: Optional[Any] = ..., **kwargs: Any
    ): ...

class RollingGroupby(_GroupByMixin, Rolling): ...

class Expanding(_Rolling_and_Expanding):
    def __init__(
        self,
        obj: Any,
        min_periods: int = ...,
        center: bool = ...,
        axis: int = ...,
        **kwargs: Any
    ) -> None: ...
    def aggregate(self, arg: Any, *args: Any, **kwargs: Any): ...
    agg: Any = ...
    def count(self, **kwargs: Any): ...
    def apply(
        self, func: Any, raw: Optional[Any] = ..., args: Any = ..., kwargs: Any = ...
    ): ...
    def sum(self, *args: Any, **kwargs: Any): ...
    def max(self, *args: Any, **kwargs: Any): ...
    def min(self, *args: Any, **kwargs: Any): ...
    def mean(self, *args: Any, **kwargs: Any): ...
    def median(self, **kwargs: Any): ...
    def std(self, ddof: int = ..., *args: Any, **kwargs: Any): ...
    def var(self, ddof: int = ..., *args: Any, **kwargs: Any): ...
    def skew(self, **kwargs: Any): ...
    def kurt(self, **kwargs: Any): ...
    def quantile(self, quantile: Any, interpolation: str = ..., **kwargs: Any): ...
    def cov(
        self,
        other: Optional[Any] = ...,
        pairwise: Optional[Any] = ...,
        ddof: int = ...,
        **kwargs: Any
    ): ...
    def corr(
        self, other: Optional[Any] = ..., pairwise: Optional[Any] = ..., **kwargs: Any
    ): ...

class ExpandingGroupby(_GroupByMixin, Expanding): ...

class EWM(_Rolling):
    obj: Any = ...
    com: Any = ...
    min_periods: Any = ...
    adjust: Any = ...
    ignore_na: Any = ...
    axis: Any = ...
    on: Any = ...
    def __init__(
        self,
        obj: Any,
        com: Optional[Any] = ...,
        span: Optional[Any] = ...,
        halflife: Optional[Any] = ...,
        alpha: Optional[Any] = ...,
        min_periods: int = ...,
        adjust: bool = ...,
        ignore_na: bool = ...,
        axis: int = ...,
    ) -> None: ...
    def aggregate(self, arg: Any, *args: Any, **kwargs: Any): ...
    agg: Any = ...
    def mean(self, *args: Any, **kwargs: Any): ...
    def std(self, bias: bool = ..., *args: Any, **kwargs: Any): ...
    vol: Any = ...
    def var(self, bias: bool = ..., *args: Any, **kwargs: Any): ...
    def cov(
        self,
        other: Optional[Any] = ...,
        pairwise: Optional[Any] = ...,
        bias: bool = ...,
        **kwargs: Any
    ): ...
    def corr(
        self, other: Optional[Any] = ..., pairwise: Optional[Any] = ..., **kwargs: Any
    ): ...

def rolling(obj: Any, win_type: Optional[Any] = ..., **kwds: Any): ...
def expanding(obj: Any, **kwds: Any): ...
def ewm(obj: Any, **kwds: Any): ...
