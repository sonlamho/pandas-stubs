# Stubs for pandas.core.arrays.datetimelike (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from .base import ExtensionArray, ExtensionOpsMixin
from typing import Any, Optional

class AttributesMixin: ...

class DatelikeOps:
    def strftime(self, date_format: Any): ...

class TimelikeOps:
    def round(self, freq: Any, ambiguous: str = ..., nonexistent: str = ...): ...
    def floor(self, freq: Any, ambiguous: str = ..., nonexistent: str = ...): ...
    def ceil(self, freq: Any, ambiguous: str = ..., nonexistent: str = ...): ...

class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray):
    def __iter__(self): ...
    @property
    def asi8(self) -> ndarray: ...
    @property
    def nbytes(self): ...
    def __array__(self, dtype: Optional[Any] = ...): ...
    @property
    def shape(self): ...
    @property
    def size(self) -> int: ...
    def __len__(self): ...
    def __getitem__(self, key: Any): ...
    def __setitem__(
        self,
        key: Union[int, Sequence[int], Sequence[bool], slice],
        value: Union[NaTType, Scalar, Sequence[Scalar]],
    ) -> None: ...
    def astype(self, dtype: Any, copy: bool = ...): ...
    def view(self, dtype: Optional[Any] = ...): ...
    def unique(self): ...
    def take(
        self, indices: Any, allow_fill: bool = ..., fill_value: Optional[Any] = ...
    ): ...
    def copy(self, deep: bool = ...): ...
    def searchsorted(
        self, value: Any, side: str = ..., sorter: Optional[Any] = ...
    ): ...
    def repeat(self, repeats: Any, *args: Any, **kwargs: Any): ...
    def value_counts(self, dropna: bool = ...): ...
    def map(self, mapper: Any): ...
    def isna(self): ...
    def fillna(
        self,
        value: Optional[Any] = ...,
        method: Optional[Any] = ...,
        limit: Optional[Any] = ...,
    ): ...
    @property
    def freq(self): ...
    @freq.setter
    def freq(self, value: Any) -> None: ...
    @property
    def freqstr(self): ...
    @property
    def inferred_freq(self): ...
    @property
    def resolution(self): ...
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def __sub__(self, other: Any): ...
    def __rsub__(self, other: Any): ...
    def __iadd__(self, other: Any): ...
    def __isub__(self, other: Any): ...
    def min(
        self, axis: Optional[Any] = ..., skipna: bool = ..., *args: Any, **kwargs: Any
    ): ...
    def max(
        self, axis: Optional[Any] = ..., skipna: bool = ..., *args: Any, **kwargs: Any
    ): ...

def validate_periods(periods: Any): ...
def validate_endpoints(closed: Any): ...
def validate_inferred_freq(freq: Any, inferred_freq: Any, freq_infer: Any): ...
def maybe_infer_freq(freq: Any): ...
