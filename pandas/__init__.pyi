# Stubs for pandas (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from pandas.core.api import *
from pandas.core.sparse.api import *
from pandas.tseries.api import *
from pandas.core.computation.api import *
from pandas.core.reshape.api import *
from pandas.io.api import *
from ._version import get_versions
from pandas.core import base, generic
from pandas.core.generic import NDFrame
from typing import Any, Optional, Iterator, Union, TypeVar, overload
from datetime import datetime, timedelta
from numpy import number, timedelta64, ndarray

__docformat__: str
hard_dependencies: Any
missing_dependencies: Any
module: Any
v: Any

_NUMBER = Union[float,int,number]

class Series(base.IndexOpsMixin, generic.NDFrame):
    hasnans: Any = ...
    def __init__(self, data: Optional[Any] = ..., index: Optional[Any] = ..., dtype: Optional[Any] = ..., name: Optional[Any] = ..., copy: bool = ..., fastpath: bool = ...) -> None: ...
    @classmethod
    def from_array(cls, arr: Any, index: Optional[Any] = ..., name: Optional[Any] = ..., dtype: Optional[Any] = ..., copy: bool = ..., fastpath: bool = ...): ...
    @property
    def name(self): ...
    @name.setter
    def name(self, value: Any) -> None: ...
    @property
    def dtype(self): ...
    @property
    def dtypes(self): ...
    @property
    def ftype(self): ...
    @property
    def ftypes(self): ...
    @property
    def values(self) -> ndarray: ...
    def get_values(self) -> ndarray: ...
    @property
    def asobject(self): ...
    def ravel(self, order: str = ...): ...
    def compress(self, condition: Any, *args: Any, **kwargs: Any): ...
    def nonzero(self): ...
    def put(self, *args: Any, **kwargs: Any) -> None: ...
    def __len__(self): ...
    def view(self, dtype: Optional[Any] = ...): ...
    def __array__(self, dtype: Optional[Any] = ...): ...
    def __array_wrap__(self, result: Any, context: Optional[Any] = ...): ...
    def __array_prepare__(self, result: Any, context: Optional[Any] = ...): ...
    @property
    def real(self): ...
    @real.setter
    def real(self, v: Any) -> None: ...
    @property
    def imag(self): ...
    @imag.setter
    def imag(self, v: Any) -> None: ...
    __float__: Any = ...
    __long__: Any = ...
    __int__: Any = ...
    @property
    def axes(self): ...
    def __getitem__(self, key: Any): ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def repeat(self, repeats: Any, axis: Optional[Any] = ...): ...
    def get_value(self, label: Any, takeable: bool = ...): ...
    def set_value(self, label: Any, value: Any, takeable: bool = ...): ...
    index: Any = ...
    def reset_index(self, level: Optional[Any] = ..., drop: bool = ..., name: Optional[Any] = ..., inplace: bool = ...): ...
    def __unicode__(self): ...
    def to_string(self, buf: Optional[Any] = ..., na_rep: str = ..., float_format: Optional[Any] = ..., header: bool = ..., index: bool = ..., length: bool = ..., dtype: bool = ..., name: bool = ..., max_rows: Optional[Any] = ...): ...
    def iteritems(self): ...
    items: Any = ...
    def keys(self): ...
    def to_dict(self, into: Any = ...): ...
    def to_frame(self, name: Optional[Any] = ...): ...
    def to_sparse(self, kind: str = ..., fill_value: Optional[Any] = ...): ...
    def count(self, level: Optional[Any] = ...): ...
    def mode(self, dropna: bool = ...): ...
    def unique(self): ...
    def drop_duplicates(self, keep: str = ..., inplace: bool = ...): ...
    def duplicated(self, keep: str = ...): ...
    def idxmin(self, axis: int = ..., skipna: bool = ..., *args: Any, **kwargs: Any): ...
    def idxmax(self, axis: int = ..., skipna: bool = ..., *args: Any, **kwargs: Any): ...
    argmin: Any = ...
    argmax: Any = ...
    def round(self, decimals: int = ..., *args: Any, **kwargs: Any): ...
    def quantile(self, q: float = ..., interpolation: str = ...): ...
    def corr(self, other: Any, method: str = ..., min_periods: Optional[Any] = ...): ...
    def cov(self, other: Any, min_periods: Optional[Any] = ...): ...
    def diff(self, periods: int = ...): ...
    def autocorr(self, lag: int = ...): ...
    def dot(self, other: Any): ...
    def __matmul__(self, other: Any): ...
    def __rmatmul__(self, other: Any): ...
    def searchsorted(self, value: Any, side: str = ..., sorter: Optional[Any] = ...): ...
    def append(self, to_append: Any, ignore_index: bool = ..., verify_integrity: bool = ...): ...
    def combine(self, other: Any, func: Any, fill_value: Optional[Any] = ...): ...
    def combine_first(self, other: Any): ...
    def update(self, other: Any) -> None: ...
    def sort_values(self, axis: int = ..., ascending: bool = ..., inplace: bool = ..., kind: str = ..., na_position: str = ...): ...
    def sort_index(self, axis: int = ..., level: Optional[Any] = ..., ascending: bool = ..., inplace: bool = ..., kind: str = ..., na_position: str = ..., sort_remaining: bool = ...): ...
    def argsort(self, axis: int = ..., kind: str = ..., order: Optional[Any] = ...): ...
    def nlargest(self, n: int = ..., keep: str = ...): ...
    def nsmallest(self, n: int = ..., keep: str = ...): ...
    def swaplevel(self, i: int = ..., j: int = ..., copy: bool = ...): ...
    def reorder_levels(self, order: Any): ...
    def unstack(self, level: int = ..., fill_value: Optional[Any] = ...): ...
    def map(self, arg: Any, na_action: Optional[Any] = ...): ...
    def aggregate(self, func: Any, axis: int = ..., *args: Any, **kwargs: Any): ...
    agg: Any = ...
    def transform(self, func: Any, axis: int = ..., *args: Any, **kwargs: Any): ...
    def apply(self, func: Any, convert_dtype: bool = ..., args: Any = ..., **kwds: Any) -> Series: ...
    def align(self, other: Any, join: str = ..., axis: Optional[Any] = ..., level: Optional[Any] = ..., copy: bool = ..., fill_value: Optional[Any] = ..., method: Optional[Any] = ..., limit: Optional[Any] = ..., fill_axis: int = ..., broadcast_axis: Optional[Any] = ...): ...
    def rename(self, index: Optional[Any] = ..., **kwargs: Any): ...
    def reindex(self, index: Optional[Any] = ..., **kwargs: Any): ...
    def drop(self, labels: Optional[Any] = ..., axis: int = ..., index: Optional[Any] = ..., columns: Optional[Any] = ..., level: Optional[Any] = ..., inplace: bool = ..., errors: str = ...): ...
    def fillna(self, value: Optional[Any] = ..., method: Optional[Any] = ..., axis: Optional[Any] = ..., inplace: bool = ..., limit: Optional[Any] = ..., downcast: Optional[Any] = ..., **kwargs: Any): ...
    def replace(self, to_replace: Optional[Any] = ..., value: Optional[Any] = ..., inplace: bool = ..., limit: Optional[Any] = ..., regex: bool = ..., method: str = ...): ...
    def shift(self, periods: int = ..., freq: Optional[Any] = ..., axis: int = ..., fill_value: Optional[Any] = ...): ...
    def memory_usage(self, index: bool = ..., deep: bool = ...): ...
    def isin(self, values: Any): ...
    def between(self, left: Any, right: Any, inclusive: bool = ...): ...
    @classmethod
    def from_csv(cls, path: Any, sep: str = ..., parse_dates: bool = ..., header: Optional[Any] = ..., index_col: int = ..., encoding: Optional[Any] = ..., infer_datetime_format: bool = ...): ...
    def to_csv(self, *args: Any, **kwargs: Any): ...
    def isna(self): ...
    def isnull(self): ...
    def notna(self): ...
    def notnull(self): ...
    def dropna(self, axis: int = ..., inplace: bool = ..., **kwargs: Any): ...
    def valid(self, inplace: bool = ..., **kwargs: Any): ...
    def to_timestamp(self, freq: Optional[Any] = ..., how: str = ..., copy: bool = ...): ...
    def to_period(self, freq: Optional[Any] = ..., copy: bool = ...): ...
    str: Any = ...
    dt: Any = ...
    cat: Any = ...
    plot: Any = ...
    sparse: Any = ...
    hist: Any = ...

class DataFrame(NDFrame):
    def __init__(self, data: Optional[Any] = ..., index: Optional[Any] = ..., columns: Optional[Any] = ..., dtype: Optional[Any] = ..., copy: bool = ...) -> None: ...
    @property
    def axes(self): ...
    @property
    def shape(self): ...
    def __unicode__(self): ...
    def to_string(self, buf: Optional[Any] = ..., columns: Optional[Any] = ..., col_space: Optional[Any] = ..., header: bool = ..., index: bool = ..., na_rep: str = ..., formatters: Optional[Any] = ..., float_format: Optional[Any] = ..., sparsify: Optional[Any] = ..., index_names: bool = ..., justify: Optional[Any] = ..., max_rows: Optional[Any] = ..., max_cols: Optional[Any] = ..., show_dimensions: bool = ..., decimal: str = ..., line_width: Optional[Any] = ...): ...
    @property
    def style(self): ...
    def iteritems(self) -> None: ...
    def iterrows(self) -> Iterator[Series]: ...
    def itertuples(self, index: bool = ..., name: str = ...): ...
    items: Any = ...
    def __len__(self): ...
    def dot(self, other: Any): ...
    def __matmul__(self, other: Any): ...
    def __rmatmul__(self, other: Any): ...
    @classmethod
    def from_dict(cls, data: Any, orient: str = ..., dtype: Optional[Any] = ..., columns: Optional[Any] = ...): ...
    def to_numpy(self, dtype: Optional[Any] = ..., copy: bool = ...): ...
    def to_dict(self, orient: str = ..., into: Any = ...): ...
    def to_gbq(self, destination_table: Any, project_id: Optional[Any] = ..., chunksize: Optional[Any] = ..., reauth: bool = ..., if_exists: str = ..., auth_local_webserver: bool = ..., table_schema: Optional[Any] = ..., location: Optional[Any] = ..., progress_bar: bool = ..., credentials: Optional[Any] = ..., verbose: Optional[Any] = ..., private_key: Optional[Any] = ...): ...
    @classmethod
    def from_records(cls, data: Any, index: Optional[Any] = ..., exclude: Optional[Any] = ..., columns: Optional[Any] = ..., coerce_float: bool = ..., nrows: Optional[Any] = ...): ...
    def to_records(self, index: bool = ..., convert_datetime64: Optional[Any] = ..., column_dtypes: Optional[Any] = ..., index_dtypes: Optional[Any] = ...): ...
    @classmethod
    def from_items(cls, items: Any, columns: Optional[Any] = ..., orient: str = ...): ...
    @classmethod
    def from_csv(cls, path: Any, header: int = ..., sep: str = ..., index_col: int = ..., parse_dates: bool = ..., encoding: Optional[Any] = ..., tupleize_cols: Optional[Any] = ..., infer_datetime_format: bool = ...): ...
    def to_sparse(self, fill_value: Optional[Any] = ..., kind: str = ...): ...
    def to_panel(self): ...
    def to_stata(self, fname: Any, convert_dates: Optional[Any] = ..., write_index: bool = ..., encoding: str = ..., byteorder: Optional[Any] = ..., time_stamp: Optional[Any] = ..., data_label: Optional[Any] = ..., variable_labels: Optional[Any] = ..., version: int = ..., convert_strl: Optional[Any] = ...) -> None: ...
    def to_feather(self, fname: Any) -> None: ...
    def to_parquet(self, fname: Any, engine: str = ..., compression: str = ..., index: Optional[Any] = ..., partition_cols: Optional[Any] = ..., **kwargs: Any) -> None: ...
    def to_html(self, buf: Optional[Any] = ..., columns: Optional[Any] = ..., col_space: Optional[Any] = ..., header: bool = ..., index: bool = ..., na_rep: str = ..., formatters: Optional[Any] = ..., float_format: Optional[Any] = ..., sparsify: Optional[Any] = ..., index_names: bool = ..., justify: Optional[Any] = ..., max_rows: Optional[Any] = ..., max_cols: Optional[Any] = ..., show_dimensions: bool = ..., decimal: str = ..., bold_rows: bool = ..., classes: Optional[Any] = ..., escape: bool = ..., notebook: bool = ..., border: Optional[Any] = ..., table_id: Optional[Any] = ..., render_links: bool = ...): ...
    def info(self, verbose: Optional[Any] = ..., buf: Optional[Any] = ..., max_cols: Optional[Any] = ..., memory_usage: Optional[Any] = ..., null_counts: Optional[Any] = ...): ...
    def memory_usage(self, index: bool = ..., deep: bool = ...): ...
    def transpose(self, *args: Any, **kwargs: Any): ...
    T: Any = ...
    def get_value(self, index: Any, col: Any, takeable: bool = ...): ...
    def set_value(self, index: Any, col: Any, value: Any, takeable: bool = ...): ...
    def __getitem__(self, key: Any): ...
    def query(self, expr: Any, inplace: bool = ..., **kwargs: Any): ...
    def eval(self, expr: Any, inplace: bool = ..., **kwargs: Any): ...
    def select_dtypes(self, include: Optional[Any] = ..., exclude: Optional[Any] = ...): ...
    def __setitem__(self, key: Any, value: Any): ...
    def insert(self, loc: Any, column: Any, value: Any, allow_duplicates: bool = ...) -> None: ...
    def assign(self, **kwargs: Any): ...
    def lookup(self, row_labels: Any, col_labels: Any): ...
    def align(self, other: Any, join: str = ..., axis: Optional[Any] = ..., level: Optional[Any] = ..., copy: bool = ..., fill_value: Optional[Any] = ..., method: Optional[Any] = ..., limit: Optional[Any] = ..., fill_axis: int = ..., broadcast_axis: Optional[Any] = ...): ...
    def reindex(self, *args: Any, **kwargs: Any): ...
    def reindex_axis(self, labels: Any, axis: int = ..., method: Optional[Any] = ..., level: Optional[Any] = ..., copy: bool = ..., limit: Optional[Any] = ..., fill_value: Optional[Any] = ...): ...
    def drop(self, labels: Optional[Any] = ..., axis: int = ..., index: Optional[Any] = ..., columns: Optional[Any] = ..., level: Optional[Any] = ..., inplace: bool = ..., errors: str = ...): ...
    def rename(self, *args: Any, **kwargs: Any): ...
    def fillna(self, value: Optional[Any] = ..., method: Optional[Any] = ..., axis: Optional[Any] = ..., inplace: bool = ..., limit: Optional[Any] = ..., downcast: Optional[Any] = ..., **kwargs: Any): ...
    def replace(self, to_replace: Optional[Any] = ..., value: Optional[Any] = ..., inplace: bool = ..., limit: Optional[Any] = ..., regex: bool = ..., method: str = ...): ...
    def shift(self, periods: int = ..., freq: Optional[Any] = ..., axis: int = ..., fill_value: Optional[Any] = ...): ...
    def set_index(self, keys: Any, drop: bool = ..., append: bool = ..., inplace: bool = ..., verify_integrity: bool = ...): ...
    def reset_index(self, level: Optional[Any] = ..., drop: bool = ..., inplace: bool = ..., col_level: int = ..., col_fill: str = ...): ...
    def isna(self): ...
    def isnull(self): ...
    def notna(self): ...
    def notnull(self): ...
    def dropna(self, axis: int = ..., how: str = ..., thresh: Optional[Any] = ..., subset: Optional[Any] = ..., inplace: bool = ...): ...
    def drop_duplicates(self, subset: Optional[Any] = ..., keep: str = ..., inplace: bool = ...): ...
    def duplicated(self, subset: Optional[Any] = ..., keep: str = ...): ...
    def sort_values(self, by: Any, axis: int = ..., ascending: bool = ..., inplace: bool = ..., kind: str = ..., na_position: str = ...): ...
    def sort_index(self, axis: int = ..., level: Optional[Any] = ..., ascending: bool = ..., inplace: bool = ..., kind: str = ..., na_position: str = ..., sort_remaining: bool = ..., by: Optional[Any] = ...): ...
    def nlargest(self, n: Any, columns: Any, keep: str = ...): ...
    def nsmallest(self, n: Any, columns: Any, keep: str = ...): ...
    def swaplevel(self, i: int = ..., j: int = ..., axis: int = ...): ...
    def reorder_levels(self, order: Any, axis: int = ...): ...
    def combine(self, other: Any, func: Any, fill_value: Optional[Any] = ..., overwrite: bool = ...): ...
    def combine_first(self, other: Any): ...
    def update(self, other: Any, join: str = ..., overwrite: bool = ..., filter_func: Optional[Any] = ..., errors: str = ...) -> None: ...
    def pivot(self, index: Optional[Any] = ..., columns: Optional[Any] = ..., values: Optional[Any] = ...): ...
    def pivot_table(self, values: Optional[Any] = ..., index: Optional[Any] = ..., columns: Optional[Any] = ..., aggfunc: str = ..., fill_value: Optional[Any] = ..., margins: bool = ..., dropna: bool = ..., margins_name: str = ...): ...
    def stack(self, level: int = ..., dropna: bool = ...): ...
    def unstack(self, level: int = ..., fill_value: Optional[Any] = ...): ...
    def melt(self, id_vars: Optional[Any] = ..., value_vars: Optional[Any] = ..., var_name: Optional[Any] = ..., value_name: str = ..., col_level: Optional[Any] = ...): ...
    def diff(self, periods: int = ..., axis: int = ...): ...
    def aggregate(self, func: Any, axis: int = ..., *args: Any, **kwargs: Any): ...
    agg: Any = ...
    def transform(self, func: Any, axis: int = ..., *args: Any, **kwargs: Any): ...
    def apply(self, func: Any, axis: int = ..., broadcast: Optional[Any] = ..., raw: bool = ..., reduce: Optional[Any] = ..., result_type: Optional[Any] = ..., args: Any = ..., **kwds: Any): ...
    def applymap(self, func: Any): ...
    def append(self, other: Any, ignore_index: bool = ..., verify_integrity: bool = ..., sort: Optional[Any] = ...): ...
    def join(self, other: Any, on: Optional[Any] = ..., how: str = ..., lsuffix: str = ..., rsuffix: str = ..., sort: bool = ...): ...
    def merge(self, right: Any, how: str = ..., on: Optional[Any] = ..., left_on: Optional[Any] = ..., right_on: Optional[Any] = ..., left_index: bool = ..., right_index: bool = ..., sort: bool = ..., suffixes: Any = ..., copy: bool = ..., indicator: bool = ..., validate: Optional[Any] = ...): ...
    def round(self, decimals: int = ..., *args: Any, **kwargs: Any): ...
    def corr(self, method: str = ..., min_periods: int = ...): ...
    def cov(self, min_periods: Optional[Any] = ...): ...
    def corrwith(self, other: Any, axis: int = ..., drop: bool = ..., method: str = ...): ...
    def count(self, axis: int = ..., level: Optional[Any] = ..., numeric_only: bool = ...): ...
    def nunique(self, axis: int = ..., dropna: bool = ...): ...
    def idxmin(self, axis: int = ..., skipna: bool = ...): ...
    def idxmax(self, axis: int = ..., skipna: bool = ...): ...
    def mode(self, axis: int = ..., numeric_only: bool = ..., dropna: bool = ...): ...
    def quantile(self, q: float = ..., axis: int = ..., numeric_only: bool = ..., interpolation: str = ...): ...
    def to_timestamp(self, freq: Optional[Any] = ..., how: str = ..., axis: int = ..., copy: bool = ...): ...
    def to_period(self, freq: Optional[Any] = ..., axis: int = ..., copy: bool = ...): ...
    def isin(self, values: Any): ...
    plot: Any = ...
    hist: Any = ...
    boxplot: Any = ...
    def __mul__(self, other: _NUMBER) -> DataFrame: ...
    def __rmul__(self, other: _NUMBER) -> DataFrame: ...

class Timestamp:
  min: Timestamp = ...
  max: Timestamp = ...
  def __new__(cls,
    ts_input: Union[Timestamp,datetime,str,int,float] = ...,
    freq: Optional[str] = ...,
    tz: Any = ..., unit: Any = ..., year: Optional[int] = ...,
    month: Optional[int] = ..., day: Optional[int] = ...,
    hour: Optional[int] = ..., minute: Optional[int] = ...,
    second: Optional[int] = ..., microsecond: Optional[int] = ...,
    nanosecond: Optional[int] = ..., tzinfo: Any = ...
  ) -> Timestamp :
    ...
  def __add__(self, other:Timedelta) -> Timestamp: ...
  def __radd__(self, other:Timedelta) -> Timestamp: ...

  @overload
  def __sub__(self, other:Timedelta) -> Timestamp: ...

  @overload
  def __sub__(self, other:Timestamp) -> Timedelta: ...

  @overload
  def __sub__(self, other:datetime) -> Timedelta: ...

  @overload
  def __rsub__(self, other:Timestamp) -> Timedelta: ...

  @overload
  def __rsub__(self, other:datetime) -> Timedelta: ...

  def __le__(self, other:Timestamp) -> bool: ...
  def __ge__(self, other:Timestamp) -> bool: ...
  def __lt__(self, other:Timestamp) -> bool: ...
  def __gt__(self, other:Timestamp) -> bool: ...
  @classmethod
  def now(cls, tz: Any=None) -> Timestamp: ...
  def to_pydatetime(self) -> datetime: ...
  def strftime(self, str) -> str: ...
  def normalize(self) -> Timestamp: ...


class Timedelta:
  days: int = ...
  delta: int = ...
  def __init__(self,
    value: Union[Timedelta,timedelta,timedelta64,str,int],
    unit: Optional[str]=..., **kwargs): ...
  def __mul__(self, other: _NUMBER) -> Timedelta: ...
  def __rmul__(self, other: _NUMBER) -> Timedelta: ...
  def __add__(self, other: Timedelta) -> Timedelta: ...
  def __sub__(self, other: Timedelta) -> Timedelta:  ...

###
def concat(objs: Any, axis: int = ..., join: str = ..., join_axes: Optional[Any] = ..., ignore_index: bool = ..., keys: Optional[Any] = ..., levels: Optional[Any] = ..., names: Optional[Any] = ..., verify_integrity: bool = ..., sort: Optional[Any] = ..., copy: bool = ...) -> DataFrame: ...

def notnull(obj: Any) -> Any: ...

def isnull(obj: Any) -> Any: ...

def read_csv(filepath_or_buffer, sep=',', delimiter=None, header='infer',
  names=None, index_col=None, usecols=None, squeeze=False, prefix=None,
  mangle_dupe_cols=True, dtype=None, engine=None, converters=None,
  true_values=None, false_values=None, skipinitialspace=False, skiprows=None,
  skipfooter=0, nrows=None, na_values=None, keep_default_na=True,
  na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False,
  infer_datetime_format=False, keep_date_col=False, date_parser=None,
  dayfirst=False, iterator=False, chunksize=None, compression='infer',
  thousands=None, decimal=b'.', lineterminator=None, quotechar='"', quoting=0,
  doublequote=True, escapechar=None, comment=None, encoding=None, dialect=None,
  tupleize_cols=None, error_bad_lines=True, warn_bad_lines=True,
  delim_whitespace=False, low_memory=True, memory_map=False,
  float_precision=None) -> DataFrame:
  ...

def date_range(start: Optional[Any] = ..., end: Optional[Any] = ..., periods: Optional[Any] = ..., freq: Optional[Any] = ..., tz: Optional[Any] = ..., normalize: bool = ..., name: Optional[Any] = ..., closed: Optional[Any] = ..., **kwargs: Any): ...
